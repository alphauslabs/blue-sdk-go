// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.31.0
// 	protoc        v3.17.3
// source: api/cover/costgroup.proto

package cover

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type CostGroupData struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id           string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name         string            `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Description  string            `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Image        string            `protobuf:"bytes,4,opt,name=image,proto3" json:"image,omitempty"`
	Icon         string            `protobuf:"bytes,5,opt,name=icon,proto3" json:"icon,omitempty"`
	ColorTheme   string            `protobuf:"bytes,6,opt,name=colorTheme,proto3" json:"colorTheme,omitempty"`
	CreatedAt    string            `protobuf:"bytes,7,opt,name=createdAt,proto3" json:"createdAt,omitempty"`
	UpdatedAt    string            `protobuf:"bytes,8,opt,name=updatedAt,proto3" json:"updatedAt,omitempty"`
	Members      []*MemberUserData `protobuf:"bytes,9,rep,name=members,proto3" json:"members,omitempty"`
	Combinations *Combinations     `protobuf:"bytes,10,opt,name=combinations,proto3" json:"combinations,omitempty"`
	CreatedBy    *MemberUserData   `protobuf:"bytes,11,opt,name=createdBy,proto3" json:"createdBy,omitempty"`
}

func (x *CostGroupData) Reset() {
	*x = CostGroupData{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_cover_costgroup_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CostGroupData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CostGroupData) ProtoMessage() {}

func (x *CostGroupData) ProtoReflect() protoreflect.Message {
	mi := &file_api_cover_costgroup_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CostGroupData.ProtoReflect.Descriptor instead.
func (*CostGroupData) Descriptor() ([]byte, []int) {
	return file_api_cover_costgroup_proto_rawDescGZIP(), []int{0}
}

func (x *CostGroupData) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *CostGroupData) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CostGroupData) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *CostGroupData) GetImage() string {
	if x != nil {
		return x.Image
	}
	return ""
}

func (x *CostGroupData) GetIcon() string {
	if x != nil {
		return x.Icon
	}
	return ""
}

func (x *CostGroupData) GetColorTheme() string {
	if x != nil {
		return x.ColorTheme
	}
	return ""
}

func (x *CostGroupData) GetCreatedAt() string {
	if x != nil {
		return x.CreatedAt
	}
	return ""
}

func (x *CostGroupData) GetUpdatedAt() string {
	if x != nil {
		return x.UpdatedAt
	}
	return ""
}

func (x *CostGroupData) GetMembers() []*MemberUserData {
	if x != nil {
		return x.Members
	}
	return nil
}

func (x *CostGroupData) GetCombinations() *Combinations {
	if x != nil {
		return x.Combinations
	}
	return nil
}

func (x *CostGroupData) GetCreatedBy() *MemberUserData {
	if x != nil {
		return x.CreatedBy
	}
	return nil
}

type Combinations struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Optional. Valid only for the `aws` vendor. AWS-specific options.
	AwsOptions *CostGroupAwsOptions `protobuf:"bytes,1,opt,name=awsOptions,proto3" json:"awsOptions,omitempty"`
	// Optional. Valid only for the `azure` vendor. Azure-specific options.
	AzureOptions *CostGroupAzureOptions `protobuf:"bytes,2,opt,name=azureOptions,proto3" json:"azureOptions,omitempty"`
	// Optional. Valid only for the `gcp` vendor. GCP-specific options.
	GcpOptions *CostGroupGcpOptions `protobuf:"bytes,3,opt,name=gcpOptions,proto3" json:"gcpOptions,omitempty"`
	// Optional. Valid only for the `azurecsp` vendor. AzureCSP-specific options.
	AzurecspOptions *CostGroupAzureCspOptions `protobuf:"bytes,4,opt,name=azurecspOptions,proto3" json:"azurecspOptions,omitempty"`
	// Optional. For custom selection when creating cost groups.
	// This field allows custom options for specifying criteria for cost group creation.
	CustomOptions *CostGroupCustomOptions `protobuf:"bytes,5,opt,name=customOptions,proto3" json:"customOptions,omitempty"`
}

func (x *Combinations) Reset() {
	*x = Combinations{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_cover_costgroup_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Combinations) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Combinations) ProtoMessage() {}

func (x *Combinations) ProtoReflect() protoreflect.Message {
	mi := &file_api_cover_costgroup_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Combinations.ProtoReflect.Descriptor instead.
func (*Combinations) Descriptor() ([]byte, []int) {
	return file_api_cover_costgroup_proto_rawDescGZIP(), []int{1}
}

func (x *Combinations) GetAwsOptions() *CostGroupAwsOptions {
	if x != nil {
		return x.AwsOptions
	}
	return nil
}

func (x *Combinations) GetAzureOptions() *CostGroupAzureOptions {
	if x != nil {
		return x.AzureOptions
	}
	return nil
}

func (x *Combinations) GetGcpOptions() *CostGroupGcpOptions {
	if x != nil {
		return x.GcpOptions
	}
	return nil
}

func (x *Combinations) GetAzurecspOptions() *CostGroupAzureCspOptions {
	if x != nil {
		return x.AzurecspOptions
	}
	return nil
}

func (x *Combinations) GetCustomOptions() *CostGroupCustomOptions {
	if x != nil {
		return x.CustomOptions
	}
	return nil
}

// AWS-specific options for CreateCostGroupRequest.
type CostGroupAwsOptions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Optional. A list of filtering options. Multiple filter items will use the logical 'or' operator, e.g. filter1 || filter2 || filter3, etc.
	// A map of "key:value" column filters. The key indicates the column name while the value is the filter value prefixed by either "eq:" (equal), "re:" (regular expressions based on https://github.com/google/re2), or "!re:" (reverse "re:"). No prefix is the same as "eq:". Multiple map items will use the logical 'and' operator, e.g. mapfilter1 && mapfilter2 && mapfilter3, etc.
	//
	// For example, if you like to filter `productCode` to return only `AmazonEC2`, set to `{"productCode":"eq:AmazonEC2"}` or `{"productCode":"AmazonEC2"}`. You can also use a regular expression like `{"productCode":"re:AmazonEC2|AmazonRDS"}`, which means return all AmazonEC2 or AmazonRDS lineitems. Or reverse regexp, such as `{"productCode":"!re:^AmazonEC2$"}`, which means return all items except `AmazonEC2`.
	Filters []*CostGroupOptionsFilters `protobuf:"bytes,1,rep,name=filters,proto3" json:"filters,omitempty"`
	// Optional. A list of filtering options. See [ReadCostsRequestAwsOptionsFilters] for more information on each filter item. Multiple filter items will use the logical 'or' operator, e.g. filter1 || filter2 || filter3, etc.
	// A map of "key:value" tag filters. The key indicates the tag key while the value is the filter tag value which can be prefixed by either "eq:" (equal), "re:" (regular expressions based on https://github.com/google/re2), or "!re:" (reverse "re:"). No prefix is the same as "eq:". Multiple map items will use the logical 'and' operator, e.g. mapfilter1 && mapfilter2 && mapfilter3, etc.
	//
	// For example, if you want to query lineitems with the tag `project:MY_PROJECT`, set to `{"project":"MY_PROJECT"}`. You can also use regular expressions for tag values, such as `{"name":"re:[A-Za-z0-9]*"}`.
	TagFilters []*CostGroupOptionsFilters `protobuf:"bytes,2,rep,name=tagFilters,proto3" json:"tagFilters,omitempty"`
}

func (x *CostGroupAwsOptions) Reset() {
	*x = CostGroupAwsOptions{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_cover_costgroup_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CostGroupAwsOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CostGroupAwsOptions) ProtoMessage() {}

func (x *CostGroupAwsOptions) ProtoReflect() protoreflect.Message {
	mi := &file_api_cover_costgroup_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CostGroupAwsOptions.ProtoReflect.Descriptor instead.
func (*CostGroupAwsOptions) Descriptor() ([]byte, []int) {
	return file_api_cover_costgroup_proto_rawDescGZIP(), []int{2}
}

func (x *CostGroupAwsOptions) GetFilters() []*CostGroupOptionsFilters {
	if x != nil {
		return x.Filters
	}
	return nil
}

func (x *CostGroupAwsOptions) GetTagFilters() []*CostGroupOptionsFilters {
	if x != nil {
		return x.TagFilters
	}
	return nil
}

// Azure-specific options for CreateCostGroupRequest.
type CostGroupAzureOptions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Optional. A list of filtering options. Multiple filter items will use the logical 'or' operator, e.g. filter1 || filter2 || filter3, etc.
	// A map of "key:value" column filters. The key indicates the column name while the value is the filter value prefixed by either "eq:" (equal), "re:" (regular expressions based on https://github.com/google/re2), or "!re:" (reverse "re:"). No prefix is the same as "eq:". Multiple map items will use the logical 'and' operator, e.g. mapfilter1 && mapfilter2 && mapfilter3, etc.
	//
	// For example, if you like to filter `productCode` to return only `AmazonEC2`, set to `{"productCode":"eq:AmazonEC2"}` or `{"productCode":"AmazonEC2"}`. You can also use a regular expression like `{"productCode":"re:AmazonEC2|AmazonRDS"}`, which means return all AmazonEC2 or AmazonRDS lineitems. Or reverse regexp, such as `{"productCode":"!re:^AmazonEC2$"}`, which means return all items except `AmazonEC2`.
	Filters []*CostGroupOptionsFilters `protobuf:"bytes,1,rep,name=filters,proto3" json:"filters,omitempty"`
	// Optional. A list of filtering options. See [ReadCostsRequestAwsOptionsFilters] for more information on each filter item. Multiple filter items will use the logical 'or' operator, e.g. filter1 || filter2 || filter3, etc.
	// A map of "key:value" tag filters. The key indicates the tag key while the value is the filter tag value which can be prefixed by either "eq:" (equal), "re:" (regular expressions based on https://github.com/google/re2), or "!re:" (reverse "re:"). No prefix is the same as "eq:". Multiple map items will use the logical 'and' operator, e.g. mapfilter1 && mapfilter2 && mapfilter3, etc.
	//
	// For example, if you want to query lineitems with the tag `project:MY_PROJECT`, set to `{"project":"MY_PROJECT"}`. You can also use regular expressions for tag values, such as `{"name":"re:[A-Za-z0-9]*"}`.
	TagFilters []*CostGroupOptionsFilters `protobuf:"bytes,2,rep,name=tagFilters,proto3" json:"tagFilters,omitempty"`
}

func (x *CostGroupAzureOptions) Reset() {
	*x = CostGroupAzureOptions{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_cover_costgroup_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CostGroupAzureOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CostGroupAzureOptions) ProtoMessage() {}

func (x *CostGroupAzureOptions) ProtoReflect() protoreflect.Message {
	mi := &file_api_cover_costgroup_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CostGroupAzureOptions.ProtoReflect.Descriptor instead.
func (*CostGroupAzureOptions) Descriptor() ([]byte, []int) {
	return file_api_cover_costgroup_proto_rawDescGZIP(), []int{3}
}

func (x *CostGroupAzureOptions) GetFilters() []*CostGroupOptionsFilters {
	if x != nil {
		return x.Filters
	}
	return nil
}

func (x *CostGroupAzureOptions) GetTagFilters() []*CostGroupOptionsFilters {
	if x != nil {
		return x.TagFilters
	}
	return nil
}

// AzureCsp-specific options for CreateCostGroupRequest.
type CostGroupAzureCspOptions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Optional. A list of filtering options. Multiple filter items will use the logical 'or' operator, e.g. filter1 || filter2 || filter3, etc.
	// A map of "key:value" column filters. The key indicates the column name while the value is the filter value prefixed by either "eq:" (equal), "re:" (regular expressions based on https://github.com/google/re2), or "!re:" (reverse "re:"). No prefix is the same as "eq:". Multiple map items will use the logical 'and' operator, e.g. mapfilter1 && mapfilter2 && mapfilter3, etc.
	//
	// For example, if you like to filter `productCode` to return only `AmazonEC2`, set to `{"productCode":"eq:AmazonEC2"}` or `{"productCode":"AmazonEC2"}`. You can also use a regular expression like `{"productCode":"re:AmazonEC2|AmazonRDS"}`, which means return all AmazonEC2 or AmazonRDS lineitems. Or reverse regexp, such as `{"productCode":"!re:^AmazonEC2$"}`, which means return all items except `AmazonEC2`.
	Filters []*CostGroupOptionsFilters `protobuf:"bytes,1,rep,name=filters,proto3" json:"filters,omitempty"`
	// Optional. A list of filtering options. See [ReadCostsRequestAwsOptionsFilters] for more information on each filter item. Multiple filter items will use the logical 'or' operator, e.g. filter1 || filter2 || filter3, etc.
	// A map of "key:value" tag filters. The key indicates the tag key while the value is the filter tag value which can be prefixed by either "eq:" (equal), "re:" (regular expressions based on https://github.com/google/re2), or "!re:" (reverse "re:"). No prefix is the same as "eq:". Multiple map items will use the logical 'and' operator, e.g. mapfilter1 && mapfilter2 && mapfilter3, etc.
	//
	// For example, if you want to query lineitems with the tag `project:MY_PROJECT`, set to `{"project":"MY_PROJECT"}`. You can also use regular expressions for tag values, such as `{"name":"re:[A-Za-z0-9]*"}`.
	TagFilters []*CostGroupOptionsFilters `protobuf:"bytes,2,rep,name=tagFilters,proto3" json:"tagFilters,omitempty"`
}

func (x *CostGroupAzureCspOptions) Reset() {
	*x = CostGroupAzureCspOptions{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_cover_costgroup_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CostGroupAzureCspOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CostGroupAzureCspOptions) ProtoMessage() {}

func (x *CostGroupAzureCspOptions) ProtoReflect() protoreflect.Message {
	mi := &file_api_cover_costgroup_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CostGroupAzureCspOptions.ProtoReflect.Descriptor instead.
func (*CostGroupAzureCspOptions) Descriptor() ([]byte, []int) {
	return file_api_cover_costgroup_proto_rawDescGZIP(), []int{4}
}

func (x *CostGroupAzureCspOptions) GetFilters() []*CostGroupOptionsFilters {
	if x != nil {
		return x.Filters
	}
	return nil
}

func (x *CostGroupAzureCspOptions) GetTagFilters() []*CostGroupOptionsFilters {
	if x != nil {
		return x.TagFilters
	}
	return nil
}

// GCP-specific options for CreateCostGroupRequest.
type CostGroupGcpOptions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Optional. A list of filtering options. Multiple filter items will use the logical 'or' operator, e.g. filter1 || filter2 || filter3, etc.
	// A map of "key:value" column filters. The key indicates the column name while the value is the filter value prefixed by either "eq:" (equal), "re:" (regular expressions based on https://github.com/google/re2), or "!re:" (reverse "re:"). No prefix is the same as "eq:". Multiple map items will use the logical 'and' operator, e.g. mapfilter1 && mapfilter2 && mapfilter3, etc.
	//
	// For example, if you like to filter `serviceDescriptinon` to return only `Cloud Spanner`, set to `{"serviceDescription":"eq:Cloud Spanner"}` or `{"serviceDescription":"Cloud Spanner"}`. You can also use a regular expression like `{"serviceDescription":"re:Cloud Spanner|BigQuery"}`, which means return all Cloud Spanner or BigQuery lineitems. Or reverse regexp, such as `{"serviceDescription":"!re:^Cloud Spanner$"}`, which means return all items except `Cloud Spanner`.
	Filters []*CostGroupOptionsFilters `protobuf:"bytes,1,rep,name=filters,proto3" json:"filters,omitempty"`
	// Tags on gcp used to conditionally allow or deny policies based on whether a supported resource has a specific tag.
	// Suppose you have a set of virtual machines (VMs) running various applications, and you want to distinguish between them based on their roles. You could assign tags like "app:webserver" and "app:database" to identify which VMs serve as web servers and which ones are database servers.
	// If you want to query lineitems with the tag `app:database`, set to `{"app":"database"}`. You can also use regular expressions for tag values, such as `{"name":"re:[A-Za-z0-9]*"}`.
	TagFilters []*CostGroupOptionsFilters `protobuf:"bytes,2,rep,name=tagFilters,proto3" json:"tagFilters,omitempty"`
	// Labels on gcp help you organize resources and manage your costs at scale, with the granularity you need.
	// For example, on Compute Engine, you can use labels to group VMs in categories such as production, staging, or development so that you can search for resources that belong to each development stage.
	// If you want to query lineitems with the label `vm-prod: prod`, set to `{"vm-prod":"prod"}`. You can also use regular expressions for tag values, such as `{"name":"re:[A-Za-z0-9]*"}`.
	Labels []*CostGroupOptionsFilters `protobuf:"bytes,3,rep,name=labels,proto3" json:"labels,omitempty"`
	// Project Labels refers to labels that have been assigned to GCP projects.
	// For example, projectId "mobingi-main" assigned as "env:prod"
	// If you want to query lineitems with the label `env: prod`, set to `{"env":"prod"}`. You can also use regular expressions for tag values, such as `{"name":"re:[A-Za-z0-9]*"}`.
	ProjectLabels []*CostGroupOptionsFilters `protobuf:"bytes,4,rep,name=projectLabels,proto3" json:"projectLabels,omitempty"`
}

func (x *CostGroupGcpOptions) Reset() {
	*x = CostGroupGcpOptions{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_cover_costgroup_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CostGroupGcpOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CostGroupGcpOptions) ProtoMessage() {}

func (x *CostGroupGcpOptions) ProtoReflect() protoreflect.Message {
	mi := &file_api_cover_costgroup_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CostGroupGcpOptions.ProtoReflect.Descriptor instead.
func (*CostGroupGcpOptions) Descriptor() ([]byte, []int) {
	return file_api_cover_costgroup_proto_rawDescGZIP(), []int{5}
}

func (x *CostGroupGcpOptions) GetFilters() []*CostGroupOptionsFilters {
	if x != nil {
		return x.Filters
	}
	return nil
}

func (x *CostGroupGcpOptions) GetTagFilters() []*CostGroupOptionsFilters {
	if x != nil {
		return x.TagFilters
	}
	return nil
}

func (x *CostGroupGcpOptions) GetLabels() []*CostGroupOptionsFilters {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *CostGroupGcpOptions) GetProjectLabels() []*CostGroupOptionsFilters {
	if x != nil {
		return x.ProjectLabels
	}
	return nil
}

// Custom-specific options for CreateCostGroupRequest.
type CostGroupCustomOptions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Optional. A list of filtering options. Multiple filter items will use the logical 'or' operator, e.g. filter1 || filter2 || filter3, etc.
	Filters []*CostGroupOptionsFilters `protobuf:"bytes,1,rep,name=filters,proto3" json:"filters,omitempty"`
}

func (x *CostGroupCustomOptions) Reset() {
	*x = CostGroupCustomOptions{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_cover_costgroup_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CostGroupCustomOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CostGroupCustomOptions) ProtoMessage() {}

func (x *CostGroupCustomOptions) ProtoReflect() protoreflect.Message {
	mi := &file_api_cover_costgroup_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CostGroupCustomOptions.ProtoReflect.Descriptor instead.
func (*CostGroupCustomOptions) Descriptor() ([]byte, []int) {
	return file_api_cover_costgroup_proto_rawDescGZIP(), []int{6}
}

func (x *CostGroupCustomOptions) GetFilters() []*CostGroupOptionsFilters {
	if x != nil {
		return x.Filters
	}
	return nil
}

type CostGroupOptionsFilters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	AndFilters map[string]string `protobuf:"bytes,1,rep,name=andFilters,proto3" json:"andFilters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *CostGroupOptionsFilters) Reset() {
	*x = CostGroupOptionsFilters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_cover_costgroup_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CostGroupOptionsFilters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CostGroupOptionsFilters) ProtoMessage() {}

func (x *CostGroupOptionsFilters) ProtoReflect() protoreflect.Message {
	mi := &file_api_cover_costgroup_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CostGroupOptionsFilters.ProtoReflect.Descriptor instead.
func (*CostGroupOptionsFilters) Descriptor() ([]byte, []int) {
	return file_api_cover_costgroup_proto_rawDescGZIP(), []int{7}
}

func (x *CostGroupOptionsFilters) GetAndFilters() map[string]string {
	if x != nil {
		return x.AndFilters
	}
	return nil
}

type Account struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	AccountId string `protobuf:"bytes,1,opt,name=accountId,proto3" json:"accountId,omitempty"`
	Name      string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Type      string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"` // account, subscription, project
}

func (x *Account) Reset() {
	*x = Account{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_cover_costgroup_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Account) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Account) ProtoMessage() {}

func (x *Account) ProtoReflect() protoreflect.Message {
	mi := &file_api_cover_costgroup_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Account.ProtoReflect.Descriptor instead.
func (*Account) Descriptor() ([]byte, []int) {
	return file_api_cover_costgroup_proto_rawDescGZIP(), []int{8}
}

func (x *Account) GetAccountId() string {
	if x != nil {
		return x.AccountId
	}
	return ""
}

func (x *Account) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Account) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

var File_api_cover_costgroup_proto protoreflect.FileDescriptor

var file_api_cover_costgroup_proto_rawDesc = []byte{
	0x0a, 0x19, 0x61, 0x70, 0x69, 0x2f, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x2f, 0x63, 0x6f, 0x73, 0x74,
	0x67, 0x72, 0x6f, 0x75, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x11, 0x62, 0x6c, 0x75,
	0x65, 0x61, 0x70, 0x69, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x1a, 0x14,
	0x61, 0x70, 0x69, 0x2f, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x22, 0x9e, 0x03, 0x0a, 0x0d, 0x43, 0x6f, 0x73, 0x74, 0x47, 0x72, 0x6f,
	0x75, 0x70, 0x44, 0x61, 0x74, 0x61, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65,
	0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x14, 0x0a, 0x05,
	0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x69, 0x6d, 0x61,
	0x67, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x69, 0x63, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x04, 0x69, 0x63, 0x6f, 0x6e, 0x12, 0x1e, 0x0a, 0x0a, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x54,
	0x68, 0x65, 0x6d, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x63, 0x6f, 0x6c, 0x6f,
	0x72, 0x54, 0x68, 0x65, 0x6d, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65,
	0x64, 0x41, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74,
	0x65, 0x64, 0x41, 0x74, 0x12, 0x1c, 0x0a, 0x09, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x41,
	0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64,
	0x41, 0x74, 0x12, 0x3b, 0x0a, 0x07, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x18, 0x09, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x62, 0x6c, 0x75, 0x65, 0x61, 0x70, 0x69, 0x2e, 0x61, 0x70,
	0x69, 0x2e, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x2e, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x55, 0x73,
	0x65, 0x72, 0x44, 0x61, 0x74, 0x61, 0x52, 0x07, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x12,
	0x43, 0x0a, 0x0c, 0x63, 0x6f, 0x6d, 0x62, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18,
	0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x62, 0x6c, 0x75, 0x65, 0x61, 0x70, 0x69, 0x2e,
	0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x2e, 0x43, 0x6f, 0x6d, 0x62, 0x69, 0x6e,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x0c, 0x63, 0x6f, 0x6d, 0x62, 0x69, 0x6e, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x73, 0x12, 0x3f, 0x0a, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x42,
	0x79, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x62, 0x6c, 0x75, 0x65, 0x61, 0x70,
	0x69, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x2e, 0x4d, 0x65, 0x6d, 0x62,
	0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x44, 0x61, 0x74, 0x61, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61,
	0x74, 0x65, 0x64, 0x42, 0x79, 0x22, 0x94, 0x03, 0x0a, 0x0c, 0x43, 0x6f, 0x6d, 0x62, 0x69, 0x6e,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x46, 0x0a, 0x0a, 0x61, 0x77, 0x73, 0x4f, 0x70, 0x74,
	0x69, 0x6f, 0x6e, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x62, 0x6c, 0x75,
	0x65, 0x61, 0x70, 0x69, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x2e, 0x43,
	0x6f, 0x73, 0x74, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x41, 0x77, 0x73, 0x4f, 0x70, 0x74, 0x69, 0x6f,
	0x6e, 0x73, 0x52, 0x0a, 0x61, 0x77, 0x73, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x4c,
	0x0a, 0x0c, 0x61, 0x7a, 0x75, 0x72, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x62, 0x6c, 0x75, 0x65, 0x61, 0x70, 0x69, 0x2e, 0x61,
	0x70, 0x69, 0x2e, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x2e, 0x43, 0x6f, 0x73, 0x74, 0x47, 0x72, 0x6f,
	0x75, 0x70, 0x41, 0x7a, 0x75, 0x72, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x0c,
	0x61, 0x7a, 0x75, 0x72, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x46, 0x0a, 0x0a,
	0x67, 0x63, 0x70, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x26, 0x2e, 0x62, 0x6c, 0x75, 0x65, 0x61, 0x70, 0x69, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x63,
	0x6f, 0x76, 0x65, 0x72, 0x2e, 0x43, 0x6f, 0x73, 0x74, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x47, 0x63,
	0x70, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x0a, 0x67, 0x63, 0x70, 0x4f, 0x70, 0x74,
	0x69, 0x6f, 0x6e, 0x73, 0x12, 0x55, 0x0a, 0x0f, 0x61, 0x7a, 0x75, 0x72, 0x65, 0x63, 0x73, 0x70,
	0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2b, 0x2e,
	0x62, 0x6c, 0x75, 0x65, 0x61, 0x70, 0x69, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x76, 0x65,
	0x72, 0x2e, 0x43, 0x6f, 0x73, 0x74, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x41, 0x7a, 0x75, 0x72, 0x65,
	0x43, 0x73, 0x70, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x0f, 0x61, 0x7a, 0x75, 0x72,
	0x65, 0x63, 0x73, 0x70, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x4f, 0x0a, 0x0d, 0x63,
	0x75, 0x73, 0x74, 0x6f, 0x6d, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x29, 0x2e, 0x62, 0x6c, 0x75, 0x65, 0x61, 0x70, 0x69, 0x2e, 0x61, 0x70, 0x69,
	0x2e, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x2e, 0x43, 0x6f, 0x73, 0x74, 0x47, 0x72, 0x6f, 0x75, 0x70,
	0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x0d, 0x63,
	0x75, 0x73, 0x74, 0x6f, 0x6d, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x22, 0xa7, 0x01, 0x0a,
	0x13, 0x43, 0x6f, 0x73, 0x74, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x41, 0x77, 0x73, 0x4f, 0x70, 0x74,
	0x69, 0x6f, 0x6e, 0x73, 0x12, 0x44, 0x0a, 0x07, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x18,
	0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x62, 0x6c, 0x75, 0x65, 0x61, 0x70, 0x69, 0x2e,
	0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x2e, 0x43, 0x6f, 0x73, 0x74, 0x47, 0x72,
	0x6f, 0x75, 0x70, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72,
	0x73, 0x52, 0x07, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x12, 0x4a, 0x0a, 0x0a, 0x74, 0x61,
	0x67, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2a,
	0x2e, 0x62, 0x6c, 0x75, 0x65, 0x61, 0x70, 0x69, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x76,
	0x65, 0x72, 0x2e, 0x43, 0x6f, 0x73, 0x74, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x4f, 0x70, 0x74, 0x69,
	0x6f, 0x6e, 0x73, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0a, 0x74, 0x61, 0x67, 0x46,
	0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x22, 0xa9, 0x01, 0x0a, 0x15, 0x43, 0x6f, 0x73, 0x74, 0x47,
	0x72, 0x6f, 0x75, 0x70, 0x41, 0x7a, 0x75, 0x72, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
	0x12, 0x44, 0x0a, 0x07, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x2a, 0x2e, 0x62, 0x6c, 0x75, 0x65, 0x61, 0x70, 0x69, 0x2e, 0x61, 0x70, 0x69, 0x2e,
	0x63, 0x6f, 0x76, 0x65, 0x72, 0x2e, 0x43, 0x6f, 0x73, 0x74, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x4f,
	0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x52, 0x07, 0x66,
	0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x12, 0x4a, 0x0a, 0x0a, 0x74, 0x61, 0x67, 0x46, 0x69, 0x6c,
	0x74, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x62, 0x6c, 0x75,
	0x65, 0x61, 0x70, 0x69, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x2e, 0x43,
	0x6f, 0x73, 0x74, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x46,
	0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0a, 0x74, 0x61, 0x67, 0x46, 0x69, 0x6c, 0x74, 0x65,
	0x72, 0x73, 0x22, 0xac, 0x01, 0x0a, 0x18, 0x43, 0x6f, 0x73, 0x74, 0x47, 0x72, 0x6f, 0x75, 0x70,
	0x41, 0x7a, 0x75, 0x72, 0x65, 0x43, 0x73, 0x70, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12,
	0x44, 0x0a, 0x07, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x2a, 0x2e, 0x62, 0x6c, 0x75, 0x65, 0x61, 0x70, 0x69, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x63,
	0x6f, 0x76, 0x65, 0x72, 0x2e, 0x43, 0x6f, 0x73, 0x74, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x4f, 0x70,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x52, 0x07, 0x66, 0x69,
	0x6c, 0x74, 0x65, 0x72, 0x73, 0x12, 0x4a, 0x0a, 0x0a, 0x74, 0x61, 0x67, 0x46, 0x69, 0x6c, 0x74,
	0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x62, 0x6c, 0x75, 0x65,
	0x61, 0x70, 0x69, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x2e, 0x43, 0x6f,
	0x73, 0x74, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x46, 0x69,
	0x6c, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0a, 0x74, 0x61, 0x67, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72,
	0x73, 0x22, 0xbd, 0x02, 0x0a, 0x13, 0x43, 0x6f, 0x73, 0x74, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x47,
	0x63, 0x70, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x44, 0x0a, 0x07, 0x66, 0x69, 0x6c,
	0x74, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x62, 0x6c, 0x75,
	0x65, 0x61, 0x70, 0x69, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x2e, 0x43,
	0x6f, 0x73, 0x74, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x46,
	0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x52, 0x07, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x12,
	0x4a, 0x0a, 0x0a, 0x74, 0x61, 0x67, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x62, 0x6c, 0x75, 0x65, 0x61, 0x70, 0x69, 0x2e, 0x61, 0x70,
	0x69, 0x2e, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x2e, 0x43, 0x6f, 0x73, 0x74, 0x47, 0x72, 0x6f, 0x75,
	0x70, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x52,
	0x0a, 0x74, 0x61, 0x67, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x12, 0x42, 0x0a, 0x06, 0x6c,
	0x61, 0x62, 0x65, 0x6c, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x62, 0x6c,
	0x75, 0x65, 0x61, 0x70, 0x69, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x2e,
	0x43, 0x6f, 0x73, 0x74, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
	0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x52, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x12,
	0x50, 0x0a, 0x0d, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73,
	0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x62, 0x6c, 0x75, 0x65, 0x61, 0x70, 0x69,
	0x2e, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x2e, 0x43, 0x6f, 0x73, 0x74, 0x47,
	0x72, 0x6f, 0x75, 0x70, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x46, 0x69, 0x6c, 0x74, 0x65,
	0x72, 0x73, 0x52, 0x0d, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x4c, 0x61, 0x62, 0x65, 0x6c,
	0x73, 0x22, 0x5e, 0x0a, 0x16, 0x43, 0x6f, 0x73, 0x74, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x43, 0x75,
	0x73, 0x74, 0x6f, 0x6d, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x44, 0x0a, 0x07, 0x66,
	0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x62,
	0x6c, 0x75, 0x65, 0x61, 0x70, 0x69, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x76, 0x65, 0x72,
	0x2e, 0x43, 0x6f, 0x73, 0x74, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x52, 0x07, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72,
	0x73, 0x22, 0xb4, 0x01, 0x0a, 0x17, 0x43, 0x6f, 0x73, 0x74, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x4f,
	0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x12, 0x5a, 0x0a,
	0x0a, 0x61, 0x6e, 0x64, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x3a, 0x2e, 0x62, 0x6c, 0x75, 0x65, 0x61, 0x70, 0x69, 0x2e, 0x61, 0x70, 0x69, 0x2e,
	0x63, 0x6f, 0x76, 0x65, 0x72, 0x2e, 0x43, 0x6f, 0x73, 0x74, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x4f,
	0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x2e, 0x41, 0x6e,
	0x64, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a, 0x61,
	0x6e, 0x64, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x1a, 0x3d, 0x0a, 0x0f, 0x41, 0x6e, 0x64,
	0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03,
	0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14,
	0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76,
	0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x4f, 0x0a, 0x07, 0x41, 0x63, 0x63, 0x6f,
	0x75, 0x6e, 0x74, 0x12, 0x1c, 0x0a, 0x09, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x49, 0x64,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x49,
	0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x42, 0x67, 0x0a, 0x1f, 0x63, 0x6c, 0x6f,
	0x75, 0x64, 0x2e, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x75, 0x73, 0x2e, 0x62, 0x6c, 0x75, 0x65, 0x61,
	0x70, 0x69, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x42, 0x16, 0x41, 0x70,
	0x69, 0x43, 0x6f, 0x76, 0x65, 0x72, 0x43, 0x6f, 0x73, 0x74, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x50,
	0x72, 0x6f, 0x74, 0x6f, 0x5a, 0x2c, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
	0x2f, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x75, 0x73, 0x6c, 0x61, 0x62, 0x73, 0x2f, 0x62, 0x6c, 0x75,
	0x65, 0x2d, 0x73, 0x64, 0x6b, 0x2d, 0x67, 0x6f, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x63, 0x6f, 0x76,
	0x65, 0x72, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_api_cover_costgroup_proto_rawDescOnce sync.Once
	file_api_cover_costgroup_proto_rawDescData = file_api_cover_costgroup_proto_rawDesc
)

func file_api_cover_costgroup_proto_rawDescGZIP() []byte {
	file_api_cover_costgroup_proto_rawDescOnce.Do(func() {
		file_api_cover_costgroup_proto_rawDescData = protoimpl.X.CompressGZIP(file_api_cover_costgroup_proto_rawDescData)
	})
	return file_api_cover_costgroup_proto_rawDescData
}

var file_api_cover_costgroup_proto_msgTypes = make([]protoimpl.MessageInfo, 10)
var file_api_cover_costgroup_proto_goTypes = []interface{}{
	(*CostGroupData)(nil),            // 0: blueapi.api.cover.CostGroupData
	(*Combinations)(nil),             // 1: blueapi.api.cover.Combinations
	(*CostGroupAwsOptions)(nil),      // 2: blueapi.api.cover.CostGroupAwsOptions
	(*CostGroupAzureOptions)(nil),    // 3: blueapi.api.cover.CostGroupAzureOptions
	(*CostGroupAzureCspOptions)(nil), // 4: blueapi.api.cover.CostGroupAzureCspOptions
	(*CostGroupGcpOptions)(nil),      // 5: blueapi.api.cover.CostGroupGcpOptions
	(*CostGroupCustomOptions)(nil),   // 6: blueapi.api.cover.CostGroupCustomOptions
	(*CostGroupOptionsFilters)(nil),  // 7: blueapi.api.cover.CostGroupOptionsFilters
	(*Account)(nil),                  // 8: blueapi.api.cover.Account
	nil,                              // 9: blueapi.api.cover.CostGroupOptionsFilters.AndFiltersEntry
	(*MemberUserData)(nil),           // 10: blueapi.api.cover.MemberUserData
}
var file_api_cover_costgroup_proto_depIdxs = []int32{
	10, // 0: blueapi.api.cover.CostGroupData.members:type_name -> blueapi.api.cover.MemberUserData
	1,  // 1: blueapi.api.cover.CostGroupData.combinations:type_name -> blueapi.api.cover.Combinations
	10, // 2: blueapi.api.cover.CostGroupData.createdBy:type_name -> blueapi.api.cover.MemberUserData
	2,  // 3: blueapi.api.cover.Combinations.awsOptions:type_name -> blueapi.api.cover.CostGroupAwsOptions
	3,  // 4: blueapi.api.cover.Combinations.azureOptions:type_name -> blueapi.api.cover.CostGroupAzureOptions
	5,  // 5: blueapi.api.cover.Combinations.gcpOptions:type_name -> blueapi.api.cover.CostGroupGcpOptions
	4,  // 6: blueapi.api.cover.Combinations.azurecspOptions:type_name -> blueapi.api.cover.CostGroupAzureCspOptions
	6,  // 7: blueapi.api.cover.Combinations.customOptions:type_name -> blueapi.api.cover.CostGroupCustomOptions
	7,  // 8: blueapi.api.cover.CostGroupAwsOptions.filters:type_name -> blueapi.api.cover.CostGroupOptionsFilters
	7,  // 9: blueapi.api.cover.CostGroupAwsOptions.tagFilters:type_name -> blueapi.api.cover.CostGroupOptionsFilters
	7,  // 10: blueapi.api.cover.CostGroupAzureOptions.filters:type_name -> blueapi.api.cover.CostGroupOptionsFilters
	7,  // 11: blueapi.api.cover.CostGroupAzureOptions.tagFilters:type_name -> blueapi.api.cover.CostGroupOptionsFilters
	7,  // 12: blueapi.api.cover.CostGroupAzureCspOptions.filters:type_name -> blueapi.api.cover.CostGroupOptionsFilters
	7,  // 13: blueapi.api.cover.CostGroupAzureCspOptions.tagFilters:type_name -> blueapi.api.cover.CostGroupOptionsFilters
	7,  // 14: blueapi.api.cover.CostGroupGcpOptions.filters:type_name -> blueapi.api.cover.CostGroupOptionsFilters
	7,  // 15: blueapi.api.cover.CostGroupGcpOptions.tagFilters:type_name -> blueapi.api.cover.CostGroupOptionsFilters
	7,  // 16: blueapi.api.cover.CostGroupGcpOptions.labels:type_name -> blueapi.api.cover.CostGroupOptionsFilters
	7,  // 17: blueapi.api.cover.CostGroupGcpOptions.projectLabels:type_name -> blueapi.api.cover.CostGroupOptionsFilters
	7,  // 18: blueapi.api.cover.CostGroupCustomOptions.filters:type_name -> blueapi.api.cover.CostGroupOptionsFilters
	9,  // 19: blueapi.api.cover.CostGroupOptionsFilters.andFilters:type_name -> blueapi.api.cover.CostGroupOptionsFilters.AndFiltersEntry
	20, // [20:20] is the sub-list for method output_type
	20, // [20:20] is the sub-list for method input_type
	20, // [20:20] is the sub-list for extension type_name
	20, // [20:20] is the sub-list for extension extendee
	0,  // [0:20] is the sub-list for field type_name
}

func init() { file_api_cover_costgroup_proto_init() }
func file_api_cover_costgroup_proto_init() {
	if File_api_cover_costgroup_proto != nil {
		return
	}
	file_api_cover_user_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_api_cover_costgroup_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CostGroupData); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_cover_costgroup_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Combinations); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_cover_costgroup_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CostGroupAwsOptions); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_cover_costgroup_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CostGroupAzureOptions); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_cover_costgroup_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CostGroupAzureCspOptions); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_cover_costgroup_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CostGroupGcpOptions); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_cover_costgroup_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CostGroupCustomOptions); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_cover_costgroup_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CostGroupOptionsFilters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_cover_costgroup_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Account); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_api_cover_costgroup_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   10,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_api_cover_costgroup_proto_goTypes,
		DependencyIndexes: file_api_cover_costgroup_proto_depIdxs,
		MessageInfos:      file_api_cover_costgroup_proto_msgTypes,
	}.Build()
	File_api_cover_costgroup_proto = out.File
	file_api_cover_costgroup_proto_rawDesc = nil
	file_api_cover_costgroup_proto_goTypes = nil
	file_api_cover_costgroup_proto_depIdxs = nil
}
